#!groovy
//Run NGINX docker build
properties([disableConcurrentBuilds()])

pipeline {
	agent {
		label 'docker-agent'
		}
	options {
		buildDiscarder (logRotator(numToKeepStr: '10', artifactNumToKeepStr: '10'))
		timestamps()
	}
	stages {
		stage("Build") {
			steps {
				echo "========= Start Build new NGINX =========="
				//Ignore ERROR with first build
				catchError (buildResult: 'SUCCESS', stageResult: 'FAILURE') {
					sh 'docker rmi mynginx_first_stable_image'
					sh 'docker tag mynginx_first mynginx_first_stable_image'
					sh 'docker rmi mynginx_first'
					sh 'docker stop mynginx_first'
					sh 'docker rename mynginx_first mynginx_first_stable'
					}
        		echo currentBuild.result
				dir ('NGINX') {
				sh 'docker build -t mynginx_first .'
				    }
				sh 'docker run --name mynginx_first -d -p 80:80 -t mynginx_first'
				sh 'docker exec mynginx_first wget -O /usr/local/nginx/html/index.html https://raw.githubusercontent.com/MiraD1n/OpsWorks/master/WebProject/index.html'
				//test error
				sh 'docker exec mynginx_first rm /usr/local/nginx/html/index.html'
				//do comment below to test crash
				sh 'docker exec mynginx_first service nginx start'
			}
		}
        stage("Test"){
            steps {
				echo "========= Start Testing =========="
				script{
					try{
						def code = sh(script: 'curl -sL --connect-timeout 20 --max-time 30 -w "%{http_code}\\n" "http://192.168.0.100/" -o /dev/null', returnStdout: true)
						if (code.trim().equals("200")) {
							echo "Good"
							catchError (buildResult: 'SUCCESS', stageResult: 'FAILURE') {	
								sh 'docker rm mynginx_first_stable'
								sh 'docker rmi mynginx_first_stable_image'
							}
							return						
						} else {
							echo "Not Good"
							sh 'docker stop mynginx_first'//остановил бракованый контейнер
							sh 'docker rm mynginx_first'//удалил бракованый контейнер
							sh 'docker rename mynginx_first_stable mynginx_first'//переименовал назад рабочий контейнер
							sh 'docker start mynginx_first'//запустил рабочий контейнер
							sh 'docker exec mynginx_first service nginx start'//запустил NGINX
							sh 'docker tag mynginx_first mynginx_first_image_bad'//переименовал бракованый образ 
							sh 'docker tag mynginx_first_stable_image mynginx_first'//переименовал стабильный образ назад
							sh 'docker rmi mynginx_first_stable_image'//удалил неактуальный тег стабильного образа
							sh 'docker rmi mynginx_first_image_bad'//удалил бракованный контейнер
							currentBuild.result = 'FAILURE'
							return
						}
					}	
					catch (exc){
						echo "Not Good"
						sh 'docker stop mynginx_first'//остановил бракованый контейнер
						sh 'docker rm mynginx_first'//удалил бракованый контейнер
						sh 'docker rename mynginx_first_stable mynginx_first'//переименовал назад рабочий контейнер
						sh 'docker start mynginx_first'//запустил рабочий контейнер
						sh 'docker exec mynginx_first service nginx start'//запустил NGINX
						sh 'docker tag mynginx_first mynginx_first_image_bad'//переименовал бракованый образ 
						sh 'docker tag mynginx_first_stable_image mynginx_first'//переименовал стабильный образ назад
						sh 'docker rmi mynginx_first_stable_image'//удалил неактуальный тег стабильного образа
						sh 'docker rmi mynginx_first_image_bad'//удалил бракованный контейнер
						currentBuild.result = 'FAILURE'
						return
					}					
				}
            }
        }
		stage("End"){	
			steps {
				//prevent failure for first build
				sh 'exit 0'
			}
		}
	}		
}
